setInterval(function(){ document.getElementById("game_canvas").style.cursor = "crosshair"; }, 1);
(function(){
var ShineTT = document.createElement("div");
ShineTT.textContent = "";
ShineTT.style.display = "none";
ShineTT.style.userSelect = "none";
ShineTT.style.webkitTouchCallout = "none";
ShineTT.style.webkitUserSelect = "none";
ShineTT.style.khtmlUserSelect = "none";
ShineTT.style.mozUserSelect = "none";
ShineTT.style.msUserSelect = "none";
ShineTT.style.position = "absolute";
ShineTT.style.color = "#FFFFFF";
ShineTT.style.font = "30px Baloo Paaji";
ShineTT.style.position = "absolute";
ShineTT.style.top = "23px";
ShineTT.style.right = "370px";
ShineTT.id = "FPSS";
ShineTT.style.textShadow = "0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black, 0 0 5px black"
document.body.appendChild(ShineTT);
var D = 700;
var TE = 0;
var F = 0;
function A1() {
var A = Date.now();
var B = A - TE;
if (B < D) {
++F;
} else {
var FF = Math.round(F / (B / 1000));
ShineTT.textContent = FF + " FPS";
F = 0;
TE = A;
}
requestAnimationFrame(A1);
}
TE = Date.now();
requestAnimationFrame(A1);
})();

function fps() {
if (document.getElementById("FPSS").style.display === "none") {
    document.getElementById("FPSS").style.display = "block";
} else {
document.getElementById("FPSS").style.display = "none";
}
};

let canvas = document.getElementById("game_canvas");
let ctx = canvas.getContext("2d");

window.xray = false;
window.normalalpha = 1;
window.xrayalpha;

if (window.xray === true) {
    window.normalalpha = window.xrayalpha;
} else {
    window.normalalpha = 1;
};

let ourangle = 0;
    function anglefinder(){
        WebSocket.prototype.send = new Proxy(WebSocket.prototype.send, {
            apply: function(target, scope, args){
                if(typeof(args[0])==='string'){
                    let json = JSON.parse(args[0]);
                    if(json[0] === 3){
                        ourangle = json[1];
                    }

                }
                let data = target.apply(scope,args);
                return data;
            }
        })
    };
let bool = false;
let aa;
let ins;
function chng() {
if (bool === false) {
bool = true;
} else {
    bool = false;
};
};

document.getElementById("loading").style.color = "#00FF00";
document.getElementById("loading").textContent = "Shine";
let sendmsg;
let hit;
let hitbool = false;
let hitinterval;
let autohit;
let msgs = [
"your noob", "so bad bro", "get good", "your actual dog$hit", "f ucking b itch",
"kill yourself loser", "pu$$yass motherf ucker", "so bad me above u"
];
let stop;

function xraychange() {
if (window.xray === true) {
    window.xray = false;
} else {
    window.xray = true;
};
};

function hitchange() {
    if (hitbool === false) {
        hitbool = true
    } else {
        hitbool = false;
    }
};

WebSocket = new Proxy(WebSocket, {
construct(target, args) {
ins = new target(...args)

    sendmsg = function() {
    if (bool === true) {
        aa = setInterval(() => {
    let packet = JSON.stringify([0, msgs[Math.floor(Math.random() * 8)]]);
    ins.send(packet);
        }, 4069);
    } else {
        clearInterval(aa);
    };
    };

    hit = function() {
        anglefinder();
        let starthit = JSON.stringify([4, ourangle]);
        ins.send(starthit);
    }

    autohit = function() {
        if (hitbool === true) {
            hit();
           // hitinterval = setInterval(() => { hit(); }, 550);
        } else {
           // clearInterval(hitinterval);
        }
    };

    let stoppacket = JSON.stringify([14]);
    stop = function() {
        ins.send(stoppacket);
    };

            return ins;
                }
            });

(function() { // autospike
    class Chest {
        constructor(x, y, id, ownerID, placeID) {
            this.x = x;
            this.y = y;
            this.id = id;
            this.ownerID = ownerID;
            this.placeID = placeID;
        }
    }

    const PlayerInfo = {
        x: null,
        y: null
    };

    const Chests = new Map();

    const handlePacket = (buffer, INT8, bool) => {
        const INT16 = new Uint16Array(buffer);
        if (bool) {
            //do something
        }
        bool = (INT8.length - 2) / 18;
        for (var i = 0; i < bool; i++) {
            var f = 2 + 18 * i;
            var g = 1 + 9 * i;
            var h = INT8[f]; //this is the player ID
            var ACTION = INT16[g + 1]; // |=
            var ID = INT16[g + 5];
            var UNIQUEID = h * 1000 + ID; //unique id in the game
            var TYPE = INT16[g + 2];
            var X = INT16[g + 3];
            var Y = INT16[g + 4];
            var INFO = INT16[g + 6];
            var v = INT16[g + 7];
            var g = INT16[g + 8];
            var ANGLE = INT16[f + 1] / 255 * Math.PI * 2;
            if (TYPE === 22) { //chest  id
                const cache_chest = Chests.get(UNIQUEID)
                if (cache_chest) {
                    cache_chest.x = X;
                    cache_chest.y = Y;
                    cache_chest.ownerID = h
                    cache_chest.id = UNIQUEID;
                } else {
                    Chests.set(UNIQUEID, new Chest(X, Y, UNIQUEID, h, ID));
                }
            }
            if (TYPE === 0) //player type is 0
            {
                if (ID === 0) {
                    //its our player
                    if (X || Y) {
                        PlayerInfo.x = X;
                        PlayerInfo.y = Y;
                    }
                }
            }
        }
    }

    const dist2D = (a, b) => {
        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))
    }

    const getNearest = (player) => {

        const nearest = {
            Chest: null,
            dist: null
        };
        Chests.forEach(Chest => {
            const dist = dist2D(player, Chest);
            if (!nearest.Chest || dist < nearest.dist) {
                nearest.dist = dist;
                nearest.Chest = Chest;
            }
        })
        return nearest.Chest;
    }
    const getFar = (player) => {

        const far = {
            Chest: null,
            dist: null
        };
        Chests.forEach(Chest => {
            const dist = dist2D(player, Chest);
            if (!far.Chest || dist + 120 < far.dist) {
                far.dist = dist;
                far.Chest = Chest;
            }
        })
        return far.Chest;
    }
    const getFar2 = (player) => {

        const far2 = {
            Chest: null,
            dist: null
        };
        Chests.forEach(Chest => {
            const dist = dist2D(player, Chest);
            if (!far2.Chest || dist - 120 < far2.dist) {
                far2.dist = dist;
                far2.Chest = Chest;
            }
        })
        return far2.Chest;
    }

    anglefinder();
    WebSocket = new Proxy(WebSocket, {
        construct(target, args) {
            const instance = new target(...args);
            const oldFrame = requestAnimationFrame;
            let lastUpdate = 0;
            const TICK_PER_SECOND = 0.01;
            const nearestChest = getNearest(PlayerInfo);
            let runOurCode = false
            window.requestAnimationFrame = function() {
                const now = performance.now();
                const delta = (now - lastUpdate);
                if (delta < 20) return oldFrame.apply(this, arguments);
                if (runOurCode) {
                    const PACKET1 = JSON.stringify([10, 213, ourangle, 0]);
                    const PACKET2 = JSON.stringify([10, 117, ourangle, 0]);
                    const PACKET3 = JSON.stringify([10, 164, ourangle, 0]);
                    const PACKET4 = JSON.stringify([10, 163, ourangle, 0]);
                    const PACKET5 = JSON.stringify([10, 156, ourangle, 0]);

                    instance.send(PACKET1);
                    instance.send(PACKET2);
                    instance.send(PACKET3);
                    instance.send(PACKET4);
                    instance.send(PACKET5);
                }
                lastUpdate = now;
                return oldFrame.apply(this, arguments)
            }
            document.addEventListener('keydown', function(e) {
                if (e.code === Utils.hacks.PUTSPIKE.key && document.getElementById("chat_block").style.display !== "inline-block") {
                    runOurCode = true;
                }
            });
            document.addEventListener('keyup', function(e) {
                if (e.code === Utils.hacks.PUTSPIKE.key && document.getElementById("chat_block").style.display !== "inline-block") {
                        runOurCode = false;
                }
            });

            instance.addEventListener("message", (e) => {
                if ("string" == typeof e.data) switch (e = JSON.parse(e.data), e[0]) {
                    default: break;
                } else {
                    var d = new Uint8Array(e.data);
                    switch (d[0]) {}
                }
            });


            instance.addEventListener("message", (e) => {
                const buffer = e.data;
                const INT8 = new Uint8Array(e.data);
                switch (typeof(buffer)) {
                case "object":
                    if (INT8[0] === 0) {
                        handlePacket(buffer, INT8, false);
                    }
                    break;
                }
            })
            return instance;
        }
    });
})();

(function() {
    class Chest{
        constructor(x,y,id,ownerID, placeID){
            this.x = x;
            this.y = y;
            this.id = id;
            this.ownerID = ownerID;
            this.placeID = placeID;
        }
    }

    const PlayerInfo = {x: null, y: null};

    const Chests = new Map();

    const handlePacket = (buffer, INT8, bool)=>{
        const INT16 = new Uint16Array(buffer);
        if (bool) {
            //do something
        }
        bool = (INT8.length - 2) / 18;
        for (var i = 0; i < bool; i++) {
            var f = 2 + 18 * i;
            var g = 1 + 9 * i;
            var h = INT8[f]; //this is the player ID
            var ACTION = INT16[g + 1]; // |=
            var ID = INT16[g + 5];
            var UNIQUEID = h * 1000 + ID; //unique id in the game

            var TYPE = INT16[g + 2];
            var X = INT16[g + 3];
            var Y = INT16[g + 4];
            var INFO = INT16[g + 6];
            var v = INT16[g + 7];
            var g = INT16[g + 8];
            var ANGLE = INT16[f + 1] / 255 * Math.PI * 2;
            if(TYPE === 11){ //chest  id
                const cache_chest = Chests.get( UNIQUEID )
                if(cache_chest){
                    cache_chest.x = X;
                    cache_chest.y = Y;
                    cache_chest.ownerID = h
                    cache_chest.id = UNIQUEID;
                }else{
                    Chests.set( UNIQUEID, new Chest(X, Y, UNIQUEID, h, ID) );
                }
            }
            if(TYPE === 0) //player type is 0
            {
                if(ID === 0){
                    //its our player
                    if(X || Y){
                        PlayerInfo.x = X;
                        PlayerInfo.y = Y;
                    }
                }
            }
        }
    }

    const dist2D = (a, b) =>{
        return Math.sqrt(Math.pow(a.x-b.x, 2) + Math.pow(a.y-b.y, 2))
    }

    const getNearest = (player)=>{

        const nearest = {Chest: null, dist: null};
        Chests.forEach(Chest=>{
            const dist = dist2D(player, Chest);
            if(!nearest.Chest || dist < nearest.dist){
                nearest.dist = dist;
                nearest.Chest = Chest;
            }
        })
        return nearest.Chest;
    }
    const getFar = (player)=>{

        const far = {Chest: null, dist: null};
        Chests.forEach(Chest=>{
            const dist = dist2D(player, Chest);
            if(!far.Chest || dist + 120 < far.dist){
                far.dist = dist;
                far.Chest = Chest;
            }
        })
        return far.Chest;
    }
    const getFar2 = (player)=>{

        const far2 = {Chest: null, dist: null};
        Chests.forEach(Chest=>{
            const dist = dist2D(player, Chest);
            if(!far2.Chest || dist - 120 < far2.dist){
                far2.dist = dist;
                far2.Chest = Chest;
            }
        })
        return far2.Chest;
    }

    WebSocket = new Proxy(WebSocket, {
        construct(target, args){
            const instance = new target(...args);

            const oldFrame = requestAnimationFrame;
            let lastUpdate = 0;
            const TICK_PER_SECOND = 0.01;
            const nearestChest = getNearest(PlayerInfo);
            let runOurCode = false
            window.requestAnimationFrame = function(){
                const now = performance.now();
                const delta = (now - lastUpdate);
                if(delta < 20) return oldFrame.apply(this,arguments);
                if(runOurCode === true){
                    if(instance.readyState === 1 && PlayerInfo.x && PlayerInfo.y){
                        const nearestChest = getNearest(PlayerInfo);
                        const farChest = getFar(PlayerInfo);
                        const far2Chest = getFar2(PlayerInfo);

                        if(nearestChest || farChest || far2Chest){
                           const PACKET = JSON.stringify([9,nearestChest.ownerID,nearestChest.placeID])
                           const PACKET2 = JSON.stringify([9,farChest.ownerID,farChest.placeID])
                           const PACKET3 = JSON.stringify([9,far2Chest.ownerID,farChest.placeID])
                           instance.send(PACKET);
                           instance.send(PACKET2);
                           instance.send(PACKET3);
                        }
                     }
                }
                lastUpdate = now;
                return oldFrame.apply(this,arguments)
            }
            document.addEventListener('keydown', function(e){
                if(e.code === Utils.hacks.STEALCHEST.key && document.getElementById("chat_block").style.display !== "inline-block"){
                    runOurCode = !runOurCode
                    }
                });

            instance.addEventListener("message", (e)=>{
                const buffer = e.data;
                const INT8 = new Uint8Array(e.data);
                switch(typeof(buffer)){
                    case "object":
                        if(INT8[0] === 0){
                            handlePacket(buffer, INT8, false);
                        }
                        break;
                }
            })
            return instance;
        }
    })
})();

(function() { // swordinchest sword in chest
    var swordsfordrop = [57,0,5,6,30,19,9,62,63,12,13,14,15,16,17,33,34,18];
    var droppingsword = 0;
    var ourangle = 0;
    class Chest{
        constructor(x,y,id,ownerID, placeID){
            this.x = x;
            this.y = y;
            this.id = id;
            this.ownerID = ownerID;
            this.placeID = placeID;
        }
    }

    const PlayerInfo = {x: null, y: null};

    const Chests = new Map();

    const handlePacket = (buffer, INT8, bool)=>{
        const INT16 = new Uint16Array(buffer);
        if (bool) {
            //do something
        }
        bool = (INT8.length - 2) / 18;
        for (var i = 0; i < bool; i++) {
            var f = 2 + 18 * i;
            var g = 1 + 9 * i;
            var h = INT8[f]; //this is the player ID
            var ACTION = INT16[g + 1]; // |=
            var ID = INT16[g + 5];
            var UNIQUEID = h * 1000 + ID; //unique id in the game

            var TYPE = INT16[g + 2];
            var X = INT16[g + 3];
            var Y = INT16[g + 4];
            var INFO = INT16[g + 6];
            var v = INT16[g + 7];
            var g = INT16[g + 8];
            var ANGLE = INT16[f + 1] / 255 * Math.PI * 2;
            if(TYPE === 11){ //chest  id
                const cache_chest = Chests.get( UNIQUEID )
                if(cache_chest){
                    cache_chest.x = X;
                    cache_chest.y = Y;
                    cache_chest.ownerID = h
                    cache_chest.id = UNIQUEID;
                }else{
                    Chests.set( UNIQUEID, new Chest(X, Y, UNIQUEID, h, ID) );
                }
            }
            if(TYPE === 0) //player type is 0
            {
                if(ID === 0){
                    //its our player
                    if(X || Y){
                        PlayerInfo.x = X;
                        PlayerInfo.y = Y;
                    }
                }
            }
        }
    }

    const dist2D = (a, b) =>{
        return Math.sqrt(Math.pow(a.x-b.x, 2) + Math.pow(a.y-b.y, 2))
    }

    const getNearest = (player)=>{

        const nearest = {Chest: null, dist: null};
        Chests.forEach(Chest=>{
            const dist = dist2D(player, Chest);
            if(!nearest.Chest || dist < nearest.dist){
                nearest.dist = dist;
                nearest.Chest = Chest;
            }
        })
        return nearest.Chest;
    }
    const getFar = (player)=>{

        const far = {Chest: null, dist: null};
        Chests.forEach(Chest=>{
            const dist = dist2D(player, Chest);
            if(!far.Chest || dist + 120 < far.dist){
                far.dist = dist;
                far.Chest = Chest;
            }
        })
        return far.Chest;
    }
    const getFar2 = (player)=>{

        const far2 = {Chest: null, dist: null};
        Chests.forEach(Chest=>{
            const dist = dist2D(player, Chest);
            if(!far2.Chest || dist - 120 < far2.dist){
                far2.dist = dist;
                far2.Chest = Chest;
            }
        })
        return far2.Chest;
    };
    function anglefinder(){
        WebSocket.prototype.send = new Proxy(WebSocket.prototype.send, {
            apply: function(target, scope, args){
                if(typeof(args[0])==='string'){
                    let json = JSON.parse(args[0]);
                    if(json[0] === 3){
                        ourangle = json[1];
                    }

                }
                let data = target.apply(scope,args);
                return data;
            }
        })
    };
    anglefinder();

    function DropSword (){
        WebSocket.prototype.send = new Proxy(WebSocket.prototype.send, {
            apply: function(target, scope, args){
                if(typeof(args[0])==='string'){
                    let json = JSON.parse(args[0]);
                        if(json[0] === 5 && swordsfordrop.includes(json[1])){
                            droppingsword = json[1];
                        }
                }
                let data = target.apply(scope,args);
                return data;
            }
        })
    };
    DropSword();
    WebSocket = new Proxy(WebSocket, {
        construct(target, args){
            const instance = new target(...args);

            const oldFrame = requestAnimationFrame;
            let lastUpdate = 0;
            const TICK_PER_SECOND = 0.01;
            const nearestChest = getNearest(PlayerInfo);
            let runOurCode = false
            window.requestAnimationFrame = function(){
                const now = performance.now();
                const delta = (now - lastUpdate);
                if(delta < 20) return oldFrame.apply(this,arguments);
                if(runOurCode){
                    if(instance.readyState === 1 && PlayerInfo.x && PlayerInfo.y){
                        const nearestChest = getNearest(PlayerInfo);
						   if(nearestChest){
                           const packet = JSON.stringify([10, 161, ourangle, 0]);
                           const packet2 = JSON.stringify([8, droppingsword, 254, nearestChest.ownerID, nearestChest.placeID]);
                           const packet3 = JSON.stringify([9, nearestChest.ownerID, nearestChest.placeID]);
                           instance.send(packet);
                           instance.send(packet2);
                           instance.send(packet3);
                           }

                     }
                }
                lastUpdate = now;
                return oldFrame.apply(this,arguments)
            }

            document.addEventListener('keydown', function(e) {
                if (e.code === Utils.hacks.SWORDINCHEST.key && document.getElementById("chat_block").style.display !== "inline-block") {
                    runOurCode = true;
                    setTimeout(() => { runOurCode = false; }, 769);
                }
            });

            instance.addEventListener("message", (e) => {
                if ("string" == typeof e.data) switch (e = JSON.parse(e.data), e[0]) {
                    default: break;
                } else {
                    var d = new Uint8Array(e.data);
                    switch (d[0]) {}
                }
            });


            instance.addEventListener("message", (e) => {
                const buffer = e.data;
                const INT8 = new Uint8Array(e.data);
                switch (typeof(buffer)) {
                case "object":
                    if (INT8[0] === 0) {
                        handlePacket(buffer, INT8, false);
                    }
                    break;
                }
            })
            return instance;
        }
    })
})();

        const To = {
            name: "Shine",
            colors: {
                menuBarBackground: "rgb(35, 35, 35)",
                menuBarText: "rgb(102, 0, 0)",
                panelBackground: "rgb(0, 0, 0)",
                componentBackground: "rgb(22, 22, 22)",
                componentForeground: "rgb(255, 255, 255)",
                textPrimary: "rgb(255, 255, 255)",
                textSecondary: "rgba(0, 255, 0, 1)",
                textHover: "rgb(0, 0, 0)"
            },
            font: {
                fontFamily: "Baloo Paaji",
                fontSize: "16px",
                fontWeight: "100"
            },
        };

         let Utils = {
            initUI: () => {
                document.body;
                let gui = new guify({
                    title: "Shine Multihack",
                    theme: To,
                    align: "right",
                    width: 550,
                    barMode: "none",
                    panelMode: "none",
                    opacity: .85,
                    root: window.container,
                    open: true
                });
                gui.Register({
                    type: 'checkbox',
                    label: 'FPS Counter',
                    onChange: () => {
                        fps();
                    }
                });
                gui.Register({
                    type: 'checkbox',
                    label: 'AutoTrashTalk',
                    onChange: () => {
                        chng();
                        sendmsg();
                    }
                });
                gui.Register({
                    type: 'checkbox',
                    label: 'AutoHit',
                    onChange: () => {
                        hitchange();
                        autohit();
                        if (hitbool === false) {
                            stop();
                        };
                    }
                });
                gui.Register({
                    type: 'text',
                    label: 'AutoSpike Key',
                    object: Utils.hacks.PUTSPIKE,
                    property: "key",
                    onChange: o => {
                        Utils.hacks.PUTSPIKE.key = o
                    }
                });
                gui.Register({
                    type: 'button',
                    label: 'Set AutoSpike Key',
                    action: o => {
                        Utils.controls.setKeyBind("PUTSPIKE")
                    }
                });
                gui.Register({
                    type: 'text',
                    label: 'StealChest Key',
                    object: Utils.hacks.STEALCHEST,
                    property: "key",
                    onChange: o => {
                        Utils.hacks.STEALCHEST.key = o
                    }
                });
                gui.Register({
                    type: 'button',
                    label: 'Set StealChest Key',
                    action: o => {
                        Utils.controls.setKeyBind("STEALCHEST")
                    }
                });
                gui.Register({
                    type: 'text',
                    label: 'SwordInChest Key',
                    object: Utils.hacks.SWORDINCHEST,
                    property: "key",
                    onChange: o => {
                        Utils.hacks.SWORDINCHEST.key = o
                    }
                });
                gui.Register({
                    type: 'button',
                    label: 'Set SwordInChest Key',
                    action: o => {
                        Utils.controls.setKeyBind("SWORDINCHEST")
                    }
                });
            },
            controls: null,
            controller: class {
                constructor() {
                    document.addEventListener("keydown", o => {
                        Object.keys(Utils.hacks).forEach(Q => {
                            const O = Utils.hacks[Q];
                            O.key === o.code && 1 == O.toggle && (O.enabled = !O.enabled);
                            O.key === o.code && 1 != O.toggle && (O.enabled = !0)
                        })
                    });
                    document.addEventListener("keyup", o => {
                        Object.keys(Utils.hacks).forEach(Q => {
                            const O = Utils.hacks[Q];
                            O.key === o.code && 1 != O.toggle && (O.enabled = !1)
                        })
                    })
                }
                setKeyBind(o) {
                    Utils.hacks[o].key = "Press any key";
                    let Q = 0;
                    document.addEventListener("keydown", function O(i) {
                        ++Q >= 1 && (Utils.hacks[o].key = i.code, document.removeEventListener("keydown", O), Utils.saveSettings())
                    })
                }
            },
            saveSettings: () => {
                localStorage.setItem("keybinds", JSON.stringify(Utils.hacks))
            },
            loadSettings: () => {
                const o = localStorage.getItem("keybinds");
                if (o) {
                    if (Object.keys(JSON.parse(o)).length != Object.keys(Utils.hacks).length) return;
                    return Utils.hacks = JSON.parse(o)
                    JSON.parse(o)
                }
            },
             hacks: {
                PUTSPIKE: {
                    key: "KeyC",
                    enabled: !1,
                    toggle: !1
                },
               STEALCHEST: {
                    key: "KeyQ",
                    enabled: !1,
                    toggle: !0
                },
                SWORDINCHEST: {
                    key: "KeyX",
                    enabled: !1,
                    toggle: !0
                },
             },
            LoadHack: () => {
                Utils.loadSettings();
                Utils.controls = new Utils.controller;
                let o = document.createElement("script");
                o.onload = function() {
                    Utils.initUI()
                };
                o.src = "https://unpkg.com/guify@0.12.0/lib/guify.min.js";
                document.body.appendChild(o)
            }
        };
Utils.LoadHack();
